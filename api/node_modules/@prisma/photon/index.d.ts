import { DMMF, DMMFClass, Engine } from './runtime';
/**
 * Utility Types
 */
export declare type Enumerable<T> = T | Array<T>;
export declare type MergeTruthyValues<R extends object, S extends object> = {
    [key in keyof S | keyof R]: key extends false ? never : key extends keyof S ? S[key] extends false ? never : S[key] : key extends keyof R ? R[key] : never;
};
export declare type CleanupNever<T> = {
    [key in keyof T]: T[key] extends never ? never : key;
}[keyof T];
/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
};
/**
 * A PhotonRequestError is an error that is thrown in conjunction to a concrete query that has been performed with Photon.js.
 */
export declare class PhotonRequestError extends Error {
    message: string;
    code?: string | undefined;
    meta?: any;
    constructor(message: string, code?: string | undefined, meta?: any);
}
declare class PhotonFetcher {
    private readonly photon;
    private readonly engine;
    private readonly debug;
    private readonly hooks?;
    constructor(photon: Photon, engine: Engine, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, path?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}
/**
 * Client
**/
export declare type Datasources = {
    db?: string;
};
export declare type LogLevel = 'INFO' | 'WARN' | 'QUERY';
export declare type LogOption = LogLevel | {
    level: LogLevel;
    /**
     * @default 'stdout'
     */
    emit?: 'event' | 'stdout';
};
export interface PhotonOptions {
    datasources?: Datasources;
    /**
     * @default false
     */
    log?: boolean | LogOption[];
    debug?: any;
    /**
     * You probably don't want to use this. `__internal` is used by internal tooling.
     */
    __internal?: {
        debug?: boolean;
        hooks?: Hooks;
        engine?: {
            cwd?: string;
            binaryPath?: string;
        };
    };
}
export declare type Hooks = {
    beforeRequest?: (options: {
        query: string;
        path: string[];
        rootField?: string;
        typeName?: string;
        document: any;
    }) => any;
};
export declare class Photon {
    private fetcher;
    private readonly dmmf;
    private readonly engine;
    private connectionPromise?;
    constructor(options?: PhotonOptions);
    private connectEngine;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    get users(): UserDelegate;
    get restaurants(): RestaurantDelegate;
    get reviews(): ReviewDelegate;
    get comments(): CommentDelegate;
}
export declare const OrderByArg: {
    asc: "asc";
    desc: "desc";
};
export declare type OrderByArg = (typeof OrderByArg)[keyof typeof OrderByArg];
export declare const Role: {
    USER: "USER";
    OWNER: "OWNER";
    ADMIN: "ADMIN";
};
export declare type Role = (typeof Role)[keyof typeof Role];
/**
 * Model User
 */
export declare type User = {
    id: number;
    username: string;
    role: Role;
    createdAt: Date;
};
export declare type UserScalars = 'id' | 'username' | 'role' | 'createdAt';
export declare type UserSelect = {
    id?: boolean;
    username?: boolean;
    role?: boolean;
    ownedRestaurants?: boolean | FindManyRestaurantSelectArgsOptional;
    authoredReviews?: boolean | FindManyReviewSelectArgsOptional;
    authoredComments?: boolean | FindManyCommentSelectArgsOptional;
    createdAt?: boolean;
};
export declare type UserInclude = {
    ownedRestaurants?: boolean | FindManyRestaurantIncludeArgsOptional;
    authoredReviews?: boolean | FindManyReviewIncludeArgsOptional;
    authoredComments?: boolean | FindManyCommentIncludeArgsOptional;
};
declare type UserDefault = {
    id: true;
    username: true;
    role: true;
    createdAt: true;
};
declare type UserGetSelectPayload<S extends boolean | UserSelect> = S extends true ? User : S extends UserSelect ? {
    [P in CleanupNever<MergeTruthyValues<{}, S>>]: P extends UserScalars ? User[P] : P extends 'ownedRestaurants' ? Array<RestaurantGetSelectPayload<ExtractFindManyRestaurantSelectArgs<S[P]>>> : P extends 'authoredReviews' ? Array<ReviewGetSelectPayload<ExtractFindManyReviewSelectArgs<S[P]>>> : P extends 'authoredComments' ? Array<CommentGetSelectPayload<ExtractFindManyCommentSelectArgs<S[P]>>> : never;
} : never;
declare type UserGetIncludePayload<S extends boolean | UserInclude> = S extends true ? User : S extends UserInclude ? {
    [P in CleanupNever<MergeTruthyValues<UserDefault, S>>]: P extends UserScalars ? User[P] : P extends 'ownedRestaurants' ? Array<RestaurantGetIncludePayload<ExtractFindManyRestaurantIncludeArgs<S[P]>>> : P extends 'authoredReviews' ? Array<ReviewGetIncludePayload<ExtractFindManyReviewIncludeArgs<S[P]>>> : P extends 'authoredComments' ? Array<CommentGetIncludePayload<ExtractFindManyCommentIncludeArgs<S[P]>>> : never;
} : never;
export interface UserDelegate {
    <T extends FindManyUserArgs>(args?: Subset<T, FindManyUserArgs>): T extends FindManyUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyUserSelectArgs ? Promise<Array<UserGetSelectPayload<ExtractFindManyUserSelectArgs<T>>>> : T extends FindManyUserIncludeArgs ? Promise<Array<UserGetIncludePayload<ExtractFindManyUserIncludeArgs<T>>>> : Promise<Array<User>>;
    findOne<T extends FindOneUserArgs>(args: Subset<T, FindOneUserArgs>): T extends FindOneUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindOneUserSelectArgs ? Promise<UserGetSelectPayload<ExtractFindOneUserSelectArgs<T>> | null> : T extends FindOneUserIncludeArgs ? Promise<UserGetIncludePayload<ExtractFindOneUserIncludeArgs<T>> | null> : UserClient<User | null>;
    findMany<T extends FindManyUserArgs>(args?: Subset<T, FindManyUserArgs>): T extends FindManyUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyUserSelectArgs ? Promise<Array<UserGetSelectPayload<ExtractFindManyUserSelectArgs<T>>>> : T extends FindManyUserIncludeArgs ? Promise<Array<UserGetIncludePayload<ExtractFindManyUserIncludeArgs<T>>>> : Promise<Array<User>>;
    create<T extends UserCreateArgs>(args: Subset<T, UserCreateArgs>): T extends UserCreateArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectCreateArgs ? Promise<UserGetSelectPayload<ExtractUserSelectCreateArgs<T>>> : T extends UserIncludeCreateArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeCreateArgs<T>>> : UserClient<User>;
    delete<T extends UserDeleteArgs>(args: Subset<T, UserDeleteArgs>): T extends UserDeleteArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectDeleteArgs ? Promise<UserGetSelectPayload<ExtractUserSelectDeleteArgs<T>>> : T extends UserIncludeDeleteArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeDeleteArgs<T>>> : UserClient<User>;
    update<T extends UserUpdateArgs>(args: Subset<T, UserUpdateArgs>): T extends UserUpdateArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectUpdateArgs ? Promise<UserGetSelectPayload<ExtractUserSelectUpdateArgs<T>>> : T extends UserIncludeUpdateArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeUpdateArgs<T>>> : UserClient<User>;
    deleteMany<T extends UserDeleteManyArgs>(args: Subset<T, UserDeleteManyArgs>): Promise<BatchPayload>;
    updateMany<T extends UserUpdateManyArgs>(args: Subset<T, UserUpdateManyArgs>): Promise<BatchPayload>;
    upsert<T extends UserUpsertArgs>(args: Subset<T, UserUpsertArgs>): T extends UserUpsertArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectUpsertArgs ? Promise<UserGetSelectPayload<ExtractUserSelectUpsertArgs<T>>> : T extends UserIncludeUpsertArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeUpsertArgs<T>>> : UserClient<User>;
    count(): Promise<number>;
}
export declare class UserClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _path;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: DMMFClass, _fetcher: PhotonFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _path: string[], _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PhotonPromise';
    ownedRestaurants<T extends FindManyRestaurantArgs = {}>(args?: Subset<T, FindManyRestaurantArgs>): T extends FindManyRestaurantArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyRestaurantSelectArgs ? Promise<Array<RestaurantGetSelectPayload<ExtractFindManyRestaurantSelectArgs<T>>>> : T extends FindManyRestaurantIncludeArgs ? Promise<Array<RestaurantGetIncludePayload<ExtractFindManyRestaurantIncludeArgs<T>>>> : Promise<Array<Restaurant>>;
    authoredReviews<T extends FindManyReviewArgs = {}>(args?: Subset<T, FindManyReviewArgs>): T extends FindManyReviewArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyReviewSelectArgs ? Promise<Array<ReviewGetSelectPayload<ExtractFindManyReviewSelectArgs<T>>>> : T extends FindManyReviewIncludeArgs ? Promise<Array<ReviewGetIncludePayload<ExtractFindManyReviewIncludeArgs<T>>>> : Promise<Array<Review>>;
    authoredComments<T extends FindManyCommentArgs = {}>(args?: Subset<T, FindManyCommentArgs>): T extends FindManyCommentArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyCommentSelectArgs ? Promise<Array<CommentGetSelectPayload<ExtractFindManyCommentSelectArgs<T>>>> : T extends FindManyCommentIncludeArgs ? Promise<Array<CommentGetIncludePayload<ExtractFindManyCommentIncludeArgs<T>>>> : Promise<Array<Comment>>;
    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
/**
 * User findOne
 */
export declare type FindOneUserArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserSelectArgs = {
    select: UserSelect;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserSelectArgsOptional = {
    select?: UserSelect | null;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserIncludeArgs = {
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserIncludeArgsOptional = {
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type ExtractFindOneUserSelectArgs<S extends undefined | boolean | FindOneUserSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneUserSelectArgs ? S['select'] : true;
export declare type ExtractFindOneUserIncludeArgs<S extends undefined | boolean | FindOneUserIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneUserIncludeArgs ? S['include'] : true;
/**
 * User findMany
 */
export declare type FindManyUserArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserSelectArgs = {
    select: UserSelect;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserSelectArgsOptional = {
    select?: UserSelect | null;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserIncludeArgs = {
    include: UserInclude;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserIncludeArgsOptional = {
    include?: UserInclude | null;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type ExtractFindManyUserSelectArgs<S extends undefined | boolean | FindManyUserSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyUserSelectArgs ? S['select'] : true;
export declare type ExtractFindManyUserIncludeArgs<S extends undefined | boolean | FindManyUserIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyUserIncludeArgs ? S['include'] : true;
/**
 * User create
 */
export declare type UserCreateArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    data: UserCreateInput;
};
export declare type UserCreateArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    data: UserCreateInput;
};
export declare type UserSelectCreateArgs = {
    select: UserSelect;
    data: UserCreateInput;
};
export declare type UserSelectCreateArgsOptional = {
    select?: UserSelect | null;
    data: UserCreateInput;
};
export declare type UserIncludeCreateArgs = {
    include: UserInclude;
    data: UserCreateInput;
};
export declare type UserIncludeCreateArgsOptional = {
    include?: UserInclude | null;
    data: UserCreateInput;
};
export declare type ExtractUserSelectCreateArgs<S extends undefined | boolean | UserSelectCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectCreateArgs ? S['select'] : true;
export declare type ExtractUserIncludeCreateArgs<S extends undefined | boolean | UserIncludeCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeCreateArgs ? S['include'] : true;
/**
 * User update
 */
export declare type UserUpdateArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserUpdateArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserSelectUpdateArgs = {
    select: UserSelect;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserSelectUpdateArgsOptional = {
    select?: UserSelect | null;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeUpdateArgs = {
    include: UserInclude;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeUpdateArgsOptional = {
    include?: UserInclude | null;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type ExtractUserSelectUpdateArgs<S extends undefined | boolean | UserSelectUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectUpdateArgs ? S['select'] : true;
export declare type ExtractUserIncludeUpdateArgs<S extends undefined | boolean | UserIncludeUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeUpdateArgs ? S['include'] : true;
/**
 * User updateMany
 */
export declare type UserUpdateManyArgs = {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput | null;
};
/**
 * User upsert
 */
export declare type UserUpsertArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserUpsertArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserSelectUpsertArgs = {
    select: UserSelect;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserSelectUpsertArgsOptional = {
    select?: UserSelect | null;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserIncludeUpsertArgs = {
    include: UserInclude;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserIncludeUpsertArgsOptional = {
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type ExtractUserSelectUpsertArgs<S extends undefined | boolean | UserSelectUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectUpsertArgs ? S['select'] : true;
export declare type ExtractUserIncludeUpsertArgs<S extends undefined | boolean | UserIncludeUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeUpsertArgs ? S['include'] : true;
/**
 * User delete
 */
export declare type UserDeleteArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type UserDeleteArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type UserSelectDeleteArgs = {
    select: UserSelect;
    where: UserWhereUniqueInput;
};
export declare type UserSelectDeleteArgsOptional = {
    select?: UserSelect | null;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeDeleteArgs = {
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeDeleteArgsOptional = {
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type ExtractUserSelectDeleteArgs<S extends undefined | boolean | UserSelectDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectDeleteArgs ? S['select'] : true;
export declare type ExtractUserIncludeDeleteArgs<S extends undefined | boolean | UserIncludeDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeDeleteArgs ? S['include'] : true;
/**
 * User deleteMany
 */
export declare type UserDeleteManyArgs = {
    where?: UserWhereInput | null;
};
/**
 * User without action
 */
export declare type UserArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
};
export declare type UserArgsRequired = {
    select: UserSelect;
    include: UserInclude;
};
export declare type UserSelectArgs = {
    select: UserSelect;
};
export declare type UserSelectArgsOptional = {
    select?: UserSelect | null;
};
export declare type UserIncludeArgs = {
    include: UserInclude;
};
export declare type UserIncludeArgsOptional = {
    include?: UserInclude | null;
};
export declare type ExtractUserSelectArgs<S extends undefined | boolean | UserSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectArgs ? S['select'] : true;
export declare type ExtractUserIncludeArgs<S extends undefined | boolean | UserIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeArgs ? S['include'] : true;
/**
 * Model Restaurant
 */
export declare type Restaurant = {
    id: number;
};
export declare type RestaurantScalars = 'id';
export declare type RestaurantSelect = {
    id?: boolean;
    creator?: boolean | UserSelectArgsOptional;
    reviews?: boolean | FindManyReviewSelectArgsOptional;
};
export declare type RestaurantInclude = {
    creator?: boolean | UserIncludeArgsOptional;
    reviews?: boolean | FindManyReviewIncludeArgsOptional;
};
declare type RestaurantDefault = {
    id: true;
};
declare type RestaurantGetSelectPayload<S extends boolean | RestaurantSelect> = S extends true ? Restaurant : S extends RestaurantSelect ? {
    [P in CleanupNever<MergeTruthyValues<{}, S>>]: P extends RestaurantScalars ? Restaurant[P] : P extends 'creator' ? UserGetSelectPayload<ExtractUserSelectArgs<S[P]>> : P extends 'reviews' ? Array<ReviewGetSelectPayload<ExtractFindManyReviewSelectArgs<S[P]>>> : never;
} : never;
declare type RestaurantGetIncludePayload<S extends boolean | RestaurantInclude> = S extends true ? Restaurant : S extends RestaurantInclude ? {
    [P in CleanupNever<MergeTruthyValues<RestaurantDefault, S>>]: P extends RestaurantScalars ? Restaurant[P] : P extends 'creator' ? UserGetIncludePayload<ExtractUserIncludeArgs<S[P]>> : P extends 'reviews' ? Array<ReviewGetIncludePayload<ExtractFindManyReviewIncludeArgs<S[P]>>> : never;
} : never;
export interface RestaurantDelegate {
    <T extends FindManyRestaurantArgs>(args?: Subset<T, FindManyRestaurantArgs>): T extends FindManyRestaurantArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyRestaurantSelectArgs ? Promise<Array<RestaurantGetSelectPayload<ExtractFindManyRestaurantSelectArgs<T>>>> : T extends FindManyRestaurantIncludeArgs ? Promise<Array<RestaurantGetIncludePayload<ExtractFindManyRestaurantIncludeArgs<T>>>> : Promise<Array<Restaurant>>;
    findOne<T extends FindOneRestaurantArgs>(args: Subset<T, FindOneRestaurantArgs>): T extends FindOneRestaurantArgsRequired ? 'Please either choose `select` or `include`' : T extends FindOneRestaurantSelectArgs ? Promise<RestaurantGetSelectPayload<ExtractFindOneRestaurantSelectArgs<T>> | null> : T extends FindOneRestaurantIncludeArgs ? Promise<RestaurantGetIncludePayload<ExtractFindOneRestaurantIncludeArgs<T>> | null> : RestaurantClient<Restaurant | null>;
    findMany<T extends FindManyRestaurantArgs>(args?: Subset<T, FindManyRestaurantArgs>): T extends FindManyRestaurantArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyRestaurantSelectArgs ? Promise<Array<RestaurantGetSelectPayload<ExtractFindManyRestaurantSelectArgs<T>>>> : T extends FindManyRestaurantIncludeArgs ? Promise<Array<RestaurantGetIncludePayload<ExtractFindManyRestaurantIncludeArgs<T>>>> : Promise<Array<Restaurant>>;
    create<T extends RestaurantCreateArgs>(args: Subset<T, RestaurantCreateArgs>): T extends RestaurantCreateArgsRequired ? 'Please either choose `select` or `include`' : T extends RestaurantSelectCreateArgs ? Promise<RestaurantGetSelectPayload<ExtractRestaurantSelectCreateArgs<T>>> : T extends RestaurantIncludeCreateArgs ? Promise<RestaurantGetIncludePayload<ExtractRestaurantIncludeCreateArgs<T>>> : RestaurantClient<Restaurant>;
    delete<T extends RestaurantDeleteArgs>(args: Subset<T, RestaurantDeleteArgs>): T extends RestaurantDeleteArgsRequired ? 'Please either choose `select` or `include`' : T extends RestaurantSelectDeleteArgs ? Promise<RestaurantGetSelectPayload<ExtractRestaurantSelectDeleteArgs<T>>> : T extends RestaurantIncludeDeleteArgs ? Promise<RestaurantGetIncludePayload<ExtractRestaurantIncludeDeleteArgs<T>>> : RestaurantClient<Restaurant>;
    update<T extends RestaurantUpdateArgs>(args: Subset<T, RestaurantUpdateArgs>): T extends RestaurantUpdateArgsRequired ? 'Please either choose `select` or `include`' : T extends RestaurantSelectUpdateArgs ? Promise<RestaurantGetSelectPayload<ExtractRestaurantSelectUpdateArgs<T>>> : T extends RestaurantIncludeUpdateArgs ? Promise<RestaurantGetIncludePayload<ExtractRestaurantIncludeUpdateArgs<T>>> : RestaurantClient<Restaurant>;
    deleteMany<T extends RestaurantDeleteManyArgs>(args: Subset<T, RestaurantDeleteManyArgs>): Promise<BatchPayload>;
    updateMany<T extends RestaurantUpdateManyArgs>(args: Subset<T, RestaurantUpdateManyArgs>): Promise<BatchPayload>;
    upsert<T extends RestaurantUpsertArgs>(args: Subset<T, RestaurantUpsertArgs>): T extends RestaurantUpsertArgsRequired ? 'Please either choose `select` or `include`' : T extends RestaurantSelectUpsertArgs ? Promise<RestaurantGetSelectPayload<ExtractRestaurantSelectUpsertArgs<T>>> : T extends RestaurantIncludeUpsertArgs ? Promise<RestaurantGetIncludePayload<ExtractRestaurantIncludeUpsertArgs<T>>> : RestaurantClient<Restaurant>;
    count(): Promise<number>;
}
export declare class RestaurantClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _path;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: DMMFClass, _fetcher: PhotonFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _path: string[], _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PhotonPromise';
    creator<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): T extends FindOneUserArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectArgs ? Promise<UserGetSelectPayload<ExtractUserSelectArgs<T>> | null> : T extends UserIncludeArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeArgs<T>> | null> : UserClient<User | null>;
    reviews<T extends FindManyReviewArgs = {}>(args?: Subset<T, FindManyReviewArgs>): T extends FindManyReviewArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyReviewSelectArgs ? Promise<Array<ReviewGetSelectPayload<ExtractFindManyReviewSelectArgs<T>>>> : T extends FindManyReviewIncludeArgs ? Promise<Array<ReviewGetIncludePayload<ExtractFindManyReviewIncludeArgs<T>>>> : Promise<Array<Review>>;
    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
/**
 * Restaurant findOne
 */
export declare type FindOneRestaurantArgs = {
    select?: RestaurantSelect | null;
    include?: RestaurantInclude | null;
    where: RestaurantWhereUniqueInput;
};
export declare type FindOneRestaurantArgsRequired = {
    select: RestaurantSelect;
    include: RestaurantInclude;
    where: RestaurantWhereUniqueInput;
};
export declare type FindOneRestaurantSelectArgs = {
    select: RestaurantSelect;
    where: RestaurantWhereUniqueInput;
};
export declare type FindOneRestaurantSelectArgsOptional = {
    select?: RestaurantSelect | null;
    where: RestaurantWhereUniqueInput;
};
export declare type FindOneRestaurantIncludeArgs = {
    include: RestaurantInclude;
    where: RestaurantWhereUniqueInput;
};
export declare type FindOneRestaurantIncludeArgsOptional = {
    include?: RestaurantInclude | null;
    where: RestaurantWhereUniqueInput;
};
export declare type ExtractFindOneRestaurantSelectArgs<S extends undefined | boolean | FindOneRestaurantSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneRestaurantSelectArgs ? S['select'] : true;
export declare type ExtractFindOneRestaurantIncludeArgs<S extends undefined | boolean | FindOneRestaurantIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneRestaurantIncludeArgs ? S['include'] : true;
/**
 * Restaurant findMany
 */
export declare type FindManyRestaurantArgs = {
    select?: RestaurantSelect | null;
    include?: RestaurantInclude | null;
    where?: RestaurantWhereInput | null;
    orderBy?: RestaurantOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyRestaurantArgsRequired = {
    select: RestaurantSelect;
    include: RestaurantInclude;
    where?: RestaurantWhereInput | null;
    orderBy?: RestaurantOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyRestaurantSelectArgs = {
    select: RestaurantSelect;
    where?: RestaurantWhereInput | null;
    orderBy?: RestaurantOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyRestaurantSelectArgsOptional = {
    select?: RestaurantSelect | null;
    where?: RestaurantWhereInput | null;
    orderBy?: RestaurantOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyRestaurantIncludeArgs = {
    include: RestaurantInclude;
    where?: RestaurantWhereInput | null;
    orderBy?: RestaurantOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyRestaurantIncludeArgsOptional = {
    include?: RestaurantInclude | null;
    where?: RestaurantWhereInput | null;
    orderBy?: RestaurantOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type ExtractFindManyRestaurantSelectArgs<S extends undefined | boolean | FindManyRestaurantSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyRestaurantSelectArgs ? S['select'] : true;
export declare type ExtractFindManyRestaurantIncludeArgs<S extends undefined | boolean | FindManyRestaurantIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyRestaurantIncludeArgs ? S['include'] : true;
/**
 * Restaurant create
 */
export declare type RestaurantCreateArgs = {
    select?: RestaurantSelect | null;
    include?: RestaurantInclude | null;
    data: RestaurantCreateInput;
};
export declare type RestaurantCreateArgsRequired = {
    select: RestaurantSelect;
    include: RestaurantInclude;
    data: RestaurantCreateInput;
};
export declare type RestaurantSelectCreateArgs = {
    select: RestaurantSelect;
    data: RestaurantCreateInput;
};
export declare type RestaurantSelectCreateArgsOptional = {
    select?: RestaurantSelect | null;
    data: RestaurantCreateInput;
};
export declare type RestaurantIncludeCreateArgs = {
    include: RestaurantInclude;
    data: RestaurantCreateInput;
};
export declare type RestaurantIncludeCreateArgsOptional = {
    include?: RestaurantInclude | null;
    data: RestaurantCreateInput;
};
export declare type ExtractRestaurantSelectCreateArgs<S extends undefined | boolean | RestaurantSelectCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RestaurantSelectCreateArgs ? S['select'] : true;
export declare type ExtractRestaurantIncludeCreateArgs<S extends undefined | boolean | RestaurantIncludeCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RestaurantIncludeCreateArgs ? S['include'] : true;
/**
 * Restaurant update
 */
export declare type RestaurantUpdateArgs = {
    select?: RestaurantSelect | null;
    include?: RestaurantInclude | null;
    data: RestaurantUpdateInput;
    where: RestaurantWhereUniqueInput;
};
export declare type RestaurantUpdateArgsRequired = {
    select: RestaurantSelect;
    include: RestaurantInclude;
    data: RestaurantUpdateInput;
    where: RestaurantWhereUniqueInput;
};
export declare type RestaurantSelectUpdateArgs = {
    select: RestaurantSelect;
    data: RestaurantUpdateInput;
    where: RestaurantWhereUniqueInput;
};
export declare type RestaurantSelectUpdateArgsOptional = {
    select?: RestaurantSelect | null;
    data: RestaurantUpdateInput;
    where: RestaurantWhereUniqueInput;
};
export declare type RestaurantIncludeUpdateArgs = {
    include: RestaurantInclude;
    data: RestaurantUpdateInput;
    where: RestaurantWhereUniqueInput;
};
export declare type RestaurantIncludeUpdateArgsOptional = {
    include?: RestaurantInclude | null;
    data: RestaurantUpdateInput;
    where: RestaurantWhereUniqueInput;
};
export declare type ExtractRestaurantSelectUpdateArgs<S extends undefined | boolean | RestaurantSelectUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RestaurantSelectUpdateArgs ? S['select'] : true;
export declare type ExtractRestaurantIncludeUpdateArgs<S extends undefined | boolean | RestaurantIncludeUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RestaurantIncludeUpdateArgs ? S['include'] : true;
/**
 * Restaurant updateMany
 */
export declare type RestaurantUpdateManyArgs = {
    data: RestaurantUpdateManyMutationInput;
    where?: RestaurantWhereInput | null;
};
/**
 * Restaurant upsert
 */
export declare type RestaurantUpsertArgs = {
    select?: RestaurantSelect | null;
    include?: RestaurantInclude | null;
    where: RestaurantWhereUniqueInput;
    create: RestaurantCreateInput;
    update: RestaurantUpdateInput;
};
export declare type RestaurantUpsertArgsRequired = {
    select: RestaurantSelect;
    include: RestaurantInclude;
    where: RestaurantWhereUniqueInput;
    create: RestaurantCreateInput;
    update: RestaurantUpdateInput;
};
export declare type RestaurantSelectUpsertArgs = {
    select: RestaurantSelect;
    where: RestaurantWhereUniqueInput;
    create: RestaurantCreateInput;
    update: RestaurantUpdateInput;
};
export declare type RestaurantSelectUpsertArgsOptional = {
    select?: RestaurantSelect | null;
    where: RestaurantWhereUniqueInput;
    create: RestaurantCreateInput;
    update: RestaurantUpdateInput;
};
export declare type RestaurantIncludeUpsertArgs = {
    include: RestaurantInclude;
    where: RestaurantWhereUniqueInput;
    create: RestaurantCreateInput;
    update: RestaurantUpdateInput;
};
export declare type RestaurantIncludeUpsertArgsOptional = {
    include?: RestaurantInclude | null;
    where: RestaurantWhereUniqueInput;
    create: RestaurantCreateInput;
    update: RestaurantUpdateInput;
};
export declare type ExtractRestaurantSelectUpsertArgs<S extends undefined | boolean | RestaurantSelectUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RestaurantSelectUpsertArgs ? S['select'] : true;
export declare type ExtractRestaurantIncludeUpsertArgs<S extends undefined | boolean | RestaurantIncludeUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RestaurantIncludeUpsertArgs ? S['include'] : true;
/**
 * Restaurant delete
 */
export declare type RestaurantDeleteArgs = {
    select?: RestaurantSelect | null;
    include?: RestaurantInclude | null;
    where: RestaurantWhereUniqueInput;
};
export declare type RestaurantDeleteArgsRequired = {
    select: RestaurantSelect;
    include: RestaurantInclude;
    where: RestaurantWhereUniqueInput;
};
export declare type RestaurantSelectDeleteArgs = {
    select: RestaurantSelect;
    where: RestaurantWhereUniqueInput;
};
export declare type RestaurantSelectDeleteArgsOptional = {
    select?: RestaurantSelect | null;
    where: RestaurantWhereUniqueInput;
};
export declare type RestaurantIncludeDeleteArgs = {
    include: RestaurantInclude;
    where: RestaurantWhereUniqueInput;
};
export declare type RestaurantIncludeDeleteArgsOptional = {
    include?: RestaurantInclude | null;
    where: RestaurantWhereUniqueInput;
};
export declare type ExtractRestaurantSelectDeleteArgs<S extends undefined | boolean | RestaurantSelectDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RestaurantSelectDeleteArgs ? S['select'] : true;
export declare type ExtractRestaurantIncludeDeleteArgs<S extends undefined | boolean | RestaurantIncludeDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RestaurantIncludeDeleteArgs ? S['include'] : true;
/**
 * Restaurant deleteMany
 */
export declare type RestaurantDeleteManyArgs = {
    where?: RestaurantWhereInput | null;
};
/**
 * Restaurant without action
 */
export declare type RestaurantArgs = {
    select?: RestaurantSelect | null;
    include?: RestaurantInclude | null;
};
export declare type RestaurantArgsRequired = {
    select: RestaurantSelect;
    include: RestaurantInclude;
};
export declare type RestaurantSelectArgs = {
    select: RestaurantSelect;
};
export declare type RestaurantSelectArgsOptional = {
    select?: RestaurantSelect | null;
};
export declare type RestaurantIncludeArgs = {
    include: RestaurantInclude;
};
export declare type RestaurantIncludeArgsOptional = {
    include?: RestaurantInclude | null;
};
export declare type ExtractRestaurantSelectArgs<S extends undefined | boolean | RestaurantSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RestaurantSelectArgs ? S['select'] : true;
export declare type ExtractRestaurantIncludeArgs<S extends undefined | boolean | RestaurantIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RestaurantIncludeArgs ? S['include'] : true;
/**
 * Model Review
 */
export declare type Review = {
    id: number;
    rating: number;
};
export declare type ReviewScalars = 'id' | 'rating';
export declare type ReviewSelect = {
    id?: boolean;
    rating?: boolean;
    restaurant?: boolean | RestaurantSelectArgsOptional;
    author?: boolean | UserSelectArgsOptional;
    comments?: boolean | FindManyCommentSelectArgsOptional;
};
export declare type ReviewInclude = {
    restaurant?: boolean | RestaurantIncludeArgsOptional;
    author?: boolean | UserIncludeArgsOptional;
    comments?: boolean | FindManyCommentIncludeArgsOptional;
};
declare type ReviewDefault = {
    id: true;
    rating: true;
};
declare type ReviewGetSelectPayload<S extends boolean | ReviewSelect> = S extends true ? Review : S extends ReviewSelect ? {
    [P in CleanupNever<MergeTruthyValues<{}, S>>]: P extends ReviewScalars ? Review[P] : P extends 'restaurant' ? RestaurantGetSelectPayload<ExtractRestaurantSelectArgs<S[P]>> : P extends 'author' ? UserGetSelectPayload<ExtractUserSelectArgs<S[P]>> : P extends 'comments' ? Array<CommentGetSelectPayload<ExtractFindManyCommentSelectArgs<S[P]>>> : never;
} : never;
declare type ReviewGetIncludePayload<S extends boolean | ReviewInclude> = S extends true ? Review : S extends ReviewInclude ? {
    [P in CleanupNever<MergeTruthyValues<ReviewDefault, S>>]: P extends ReviewScalars ? Review[P] : P extends 'restaurant' ? RestaurantGetIncludePayload<ExtractRestaurantIncludeArgs<S[P]>> : P extends 'author' ? UserGetIncludePayload<ExtractUserIncludeArgs<S[P]>> : P extends 'comments' ? Array<CommentGetIncludePayload<ExtractFindManyCommentIncludeArgs<S[P]>>> : never;
} : never;
export interface ReviewDelegate {
    <T extends FindManyReviewArgs>(args?: Subset<T, FindManyReviewArgs>): T extends FindManyReviewArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyReviewSelectArgs ? Promise<Array<ReviewGetSelectPayload<ExtractFindManyReviewSelectArgs<T>>>> : T extends FindManyReviewIncludeArgs ? Promise<Array<ReviewGetIncludePayload<ExtractFindManyReviewIncludeArgs<T>>>> : Promise<Array<Review>>;
    findOne<T extends FindOneReviewArgs>(args: Subset<T, FindOneReviewArgs>): T extends FindOneReviewArgsRequired ? 'Please either choose `select` or `include`' : T extends FindOneReviewSelectArgs ? Promise<ReviewGetSelectPayload<ExtractFindOneReviewSelectArgs<T>> | null> : T extends FindOneReviewIncludeArgs ? Promise<ReviewGetIncludePayload<ExtractFindOneReviewIncludeArgs<T>> | null> : ReviewClient<Review | null>;
    findMany<T extends FindManyReviewArgs>(args?: Subset<T, FindManyReviewArgs>): T extends FindManyReviewArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyReviewSelectArgs ? Promise<Array<ReviewGetSelectPayload<ExtractFindManyReviewSelectArgs<T>>>> : T extends FindManyReviewIncludeArgs ? Promise<Array<ReviewGetIncludePayload<ExtractFindManyReviewIncludeArgs<T>>>> : Promise<Array<Review>>;
    create<T extends ReviewCreateArgs>(args: Subset<T, ReviewCreateArgs>): T extends ReviewCreateArgsRequired ? 'Please either choose `select` or `include`' : T extends ReviewSelectCreateArgs ? Promise<ReviewGetSelectPayload<ExtractReviewSelectCreateArgs<T>>> : T extends ReviewIncludeCreateArgs ? Promise<ReviewGetIncludePayload<ExtractReviewIncludeCreateArgs<T>>> : ReviewClient<Review>;
    delete<T extends ReviewDeleteArgs>(args: Subset<T, ReviewDeleteArgs>): T extends ReviewDeleteArgsRequired ? 'Please either choose `select` or `include`' : T extends ReviewSelectDeleteArgs ? Promise<ReviewGetSelectPayload<ExtractReviewSelectDeleteArgs<T>>> : T extends ReviewIncludeDeleteArgs ? Promise<ReviewGetIncludePayload<ExtractReviewIncludeDeleteArgs<T>>> : ReviewClient<Review>;
    update<T extends ReviewUpdateArgs>(args: Subset<T, ReviewUpdateArgs>): T extends ReviewUpdateArgsRequired ? 'Please either choose `select` or `include`' : T extends ReviewSelectUpdateArgs ? Promise<ReviewGetSelectPayload<ExtractReviewSelectUpdateArgs<T>>> : T extends ReviewIncludeUpdateArgs ? Promise<ReviewGetIncludePayload<ExtractReviewIncludeUpdateArgs<T>>> : ReviewClient<Review>;
    deleteMany<T extends ReviewDeleteManyArgs>(args: Subset<T, ReviewDeleteManyArgs>): Promise<BatchPayload>;
    updateMany<T extends ReviewUpdateManyArgs>(args: Subset<T, ReviewUpdateManyArgs>): Promise<BatchPayload>;
    upsert<T extends ReviewUpsertArgs>(args: Subset<T, ReviewUpsertArgs>): T extends ReviewUpsertArgsRequired ? 'Please either choose `select` or `include`' : T extends ReviewSelectUpsertArgs ? Promise<ReviewGetSelectPayload<ExtractReviewSelectUpsertArgs<T>>> : T extends ReviewIncludeUpsertArgs ? Promise<ReviewGetIncludePayload<ExtractReviewIncludeUpsertArgs<T>>> : ReviewClient<Review>;
    count(): Promise<number>;
}
export declare class ReviewClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _path;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: DMMFClass, _fetcher: PhotonFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _path: string[], _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PhotonPromise';
    restaurant<T extends RestaurantArgs = {}>(args?: Subset<T, RestaurantArgs>): T extends FindOneRestaurantArgsRequired ? 'Please either choose `select` or `include`' : T extends RestaurantSelectArgs ? Promise<RestaurantGetSelectPayload<ExtractRestaurantSelectArgs<T>> | null> : T extends RestaurantIncludeArgs ? Promise<RestaurantGetIncludePayload<ExtractRestaurantIncludeArgs<T>> | null> : RestaurantClient<Restaurant | null>;
    author<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): T extends FindOneUserArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectArgs ? Promise<UserGetSelectPayload<ExtractUserSelectArgs<T>> | null> : T extends UserIncludeArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeArgs<T>> | null> : UserClient<User | null>;
    comments<T extends FindManyCommentArgs = {}>(args?: Subset<T, FindManyCommentArgs>): T extends FindManyCommentArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyCommentSelectArgs ? Promise<Array<CommentGetSelectPayload<ExtractFindManyCommentSelectArgs<T>>>> : T extends FindManyCommentIncludeArgs ? Promise<Array<CommentGetIncludePayload<ExtractFindManyCommentIncludeArgs<T>>>> : Promise<Array<Comment>>;
    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
/**
 * Review findOne
 */
export declare type FindOneReviewArgs = {
    select?: ReviewSelect | null;
    include?: ReviewInclude | null;
    where: ReviewWhereUniqueInput;
};
export declare type FindOneReviewArgsRequired = {
    select: ReviewSelect;
    include: ReviewInclude;
    where: ReviewWhereUniqueInput;
};
export declare type FindOneReviewSelectArgs = {
    select: ReviewSelect;
    where: ReviewWhereUniqueInput;
};
export declare type FindOneReviewSelectArgsOptional = {
    select?: ReviewSelect | null;
    where: ReviewWhereUniqueInput;
};
export declare type FindOneReviewIncludeArgs = {
    include: ReviewInclude;
    where: ReviewWhereUniqueInput;
};
export declare type FindOneReviewIncludeArgsOptional = {
    include?: ReviewInclude | null;
    where: ReviewWhereUniqueInput;
};
export declare type ExtractFindOneReviewSelectArgs<S extends undefined | boolean | FindOneReviewSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneReviewSelectArgs ? S['select'] : true;
export declare type ExtractFindOneReviewIncludeArgs<S extends undefined | boolean | FindOneReviewIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneReviewIncludeArgs ? S['include'] : true;
/**
 * Review findMany
 */
export declare type FindManyReviewArgs = {
    select?: ReviewSelect | null;
    include?: ReviewInclude | null;
    where?: ReviewWhereInput | null;
    orderBy?: ReviewOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyReviewArgsRequired = {
    select: ReviewSelect;
    include: ReviewInclude;
    where?: ReviewWhereInput | null;
    orderBy?: ReviewOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyReviewSelectArgs = {
    select: ReviewSelect;
    where?: ReviewWhereInput | null;
    orderBy?: ReviewOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyReviewSelectArgsOptional = {
    select?: ReviewSelect | null;
    where?: ReviewWhereInput | null;
    orderBy?: ReviewOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyReviewIncludeArgs = {
    include: ReviewInclude;
    where?: ReviewWhereInput | null;
    orderBy?: ReviewOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyReviewIncludeArgsOptional = {
    include?: ReviewInclude | null;
    where?: ReviewWhereInput | null;
    orderBy?: ReviewOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type ExtractFindManyReviewSelectArgs<S extends undefined | boolean | FindManyReviewSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyReviewSelectArgs ? S['select'] : true;
export declare type ExtractFindManyReviewIncludeArgs<S extends undefined | boolean | FindManyReviewIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyReviewIncludeArgs ? S['include'] : true;
/**
 * Review create
 */
export declare type ReviewCreateArgs = {
    select?: ReviewSelect | null;
    include?: ReviewInclude | null;
    data: ReviewCreateInput;
};
export declare type ReviewCreateArgsRequired = {
    select: ReviewSelect;
    include: ReviewInclude;
    data: ReviewCreateInput;
};
export declare type ReviewSelectCreateArgs = {
    select: ReviewSelect;
    data: ReviewCreateInput;
};
export declare type ReviewSelectCreateArgsOptional = {
    select?: ReviewSelect | null;
    data: ReviewCreateInput;
};
export declare type ReviewIncludeCreateArgs = {
    include: ReviewInclude;
    data: ReviewCreateInput;
};
export declare type ReviewIncludeCreateArgsOptional = {
    include?: ReviewInclude | null;
    data: ReviewCreateInput;
};
export declare type ExtractReviewSelectCreateArgs<S extends undefined | boolean | ReviewSelectCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ReviewSelectCreateArgs ? S['select'] : true;
export declare type ExtractReviewIncludeCreateArgs<S extends undefined | boolean | ReviewIncludeCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ReviewIncludeCreateArgs ? S['include'] : true;
/**
 * Review update
 */
export declare type ReviewUpdateArgs = {
    select?: ReviewSelect | null;
    include?: ReviewInclude | null;
    data: ReviewUpdateInput;
    where: ReviewWhereUniqueInput;
};
export declare type ReviewUpdateArgsRequired = {
    select: ReviewSelect;
    include: ReviewInclude;
    data: ReviewUpdateInput;
    where: ReviewWhereUniqueInput;
};
export declare type ReviewSelectUpdateArgs = {
    select: ReviewSelect;
    data: ReviewUpdateInput;
    where: ReviewWhereUniqueInput;
};
export declare type ReviewSelectUpdateArgsOptional = {
    select?: ReviewSelect | null;
    data: ReviewUpdateInput;
    where: ReviewWhereUniqueInput;
};
export declare type ReviewIncludeUpdateArgs = {
    include: ReviewInclude;
    data: ReviewUpdateInput;
    where: ReviewWhereUniqueInput;
};
export declare type ReviewIncludeUpdateArgsOptional = {
    include?: ReviewInclude | null;
    data: ReviewUpdateInput;
    where: ReviewWhereUniqueInput;
};
export declare type ExtractReviewSelectUpdateArgs<S extends undefined | boolean | ReviewSelectUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ReviewSelectUpdateArgs ? S['select'] : true;
export declare type ExtractReviewIncludeUpdateArgs<S extends undefined | boolean | ReviewIncludeUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ReviewIncludeUpdateArgs ? S['include'] : true;
/**
 * Review updateMany
 */
export declare type ReviewUpdateManyArgs = {
    data: ReviewUpdateManyMutationInput;
    where?: ReviewWhereInput | null;
};
/**
 * Review upsert
 */
export declare type ReviewUpsertArgs = {
    select?: ReviewSelect | null;
    include?: ReviewInclude | null;
    where: ReviewWhereUniqueInput;
    create: ReviewCreateInput;
    update: ReviewUpdateInput;
};
export declare type ReviewUpsertArgsRequired = {
    select: ReviewSelect;
    include: ReviewInclude;
    where: ReviewWhereUniqueInput;
    create: ReviewCreateInput;
    update: ReviewUpdateInput;
};
export declare type ReviewSelectUpsertArgs = {
    select: ReviewSelect;
    where: ReviewWhereUniqueInput;
    create: ReviewCreateInput;
    update: ReviewUpdateInput;
};
export declare type ReviewSelectUpsertArgsOptional = {
    select?: ReviewSelect | null;
    where: ReviewWhereUniqueInput;
    create: ReviewCreateInput;
    update: ReviewUpdateInput;
};
export declare type ReviewIncludeUpsertArgs = {
    include: ReviewInclude;
    where: ReviewWhereUniqueInput;
    create: ReviewCreateInput;
    update: ReviewUpdateInput;
};
export declare type ReviewIncludeUpsertArgsOptional = {
    include?: ReviewInclude | null;
    where: ReviewWhereUniqueInput;
    create: ReviewCreateInput;
    update: ReviewUpdateInput;
};
export declare type ExtractReviewSelectUpsertArgs<S extends undefined | boolean | ReviewSelectUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ReviewSelectUpsertArgs ? S['select'] : true;
export declare type ExtractReviewIncludeUpsertArgs<S extends undefined | boolean | ReviewIncludeUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ReviewIncludeUpsertArgs ? S['include'] : true;
/**
 * Review delete
 */
export declare type ReviewDeleteArgs = {
    select?: ReviewSelect | null;
    include?: ReviewInclude | null;
    where: ReviewWhereUniqueInput;
};
export declare type ReviewDeleteArgsRequired = {
    select: ReviewSelect;
    include: ReviewInclude;
    where: ReviewWhereUniqueInput;
};
export declare type ReviewSelectDeleteArgs = {
    select: ReviewSelect;
    where: ReviewWhereUniqueInput;
};
export declare type ReviewSelectDeleteArgsOptional = {
    select?: ReviewSelect | null;
    where: ReviewWhereUniqueInput;
};
export declare type ReviewIncludeDeleteArgs = {
    include: ReviewInclude;
    where: ReviewWhereUniqueInput;
};
export declare type ReviewIncludeDeleteArgsOptional = {
    include?: ReviewInclude | null;
    where: ReviewWhereUniqueInput;
};
export declare type ExtractReviewSelectDeleteArgs<S extends undefined | boolean | ReviewSelectDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ReviewSelectDeleteArgs ? S['select'] : true;
export declare type ExtractReviewIncludeDeleteArgs<S extends undefined | boolean | ReviewIncludeDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ReviewIncludeDeleteArgs ? S['include'] : true;
/**
 * Review deleteMany
 */
export declare type ReviewDeleteManyArgs = {
    where?: ReviewWhereInput | null;
};
/**
 * Review without action
 */
export declare type ReviewArgs = {
    select?: ReviewSelect | null;
    include?: ReviewInclude | null;
};
export declare type ReviewArgsRequired = {
    select: ReviewSelect;
    include: ReviewInclude;
};
export declare type ReviewSelectArgs = {
    select: ReviewSelect;
};
export declare type ReviewSelectArgsOptional = {
    select?: ReviewSelect | null;
};
export declare type ReviewIncludeArgs = {
    include: ReviewInclude;
};
export declare type ReviewIncludeArgsOptional = {
    include?: ReviewInclude | null;
};
export declare type ExtractReviewSelectArgs<S extends undefined | boolean | ReviewSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ReviewSelectArgs ? S['select'] : true;
export declare type ExtractReviewIncludeArgs<S extends undefined | boolean | ReviewIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ReviewIncludeArgs ? S['include'] : true;
/**
 * Model Comment
 */
export declare type Comment = {
    id: number;
    createdAt: Date;
    updatedAt: Date;
};
export declare type CommentScalars = 'id' | 'createdAt' | 'updatedAt';
export declare type CommentSelect = {
    id?: boolean;
    author?: boolean | UserSelectArgsOptional;
    createdAt?: boolean;
    updatedAt?: boolean;
    review?: boolean | ReviewSelectArgsOptional;
};
export declare type CommentInclude = {
    author?: boolean | UserIncludeArgsOptional;
    review?: boolean | ReviewIncludeArgsOptional;
};
declare type CommentDefault = {
    id: true;
    createdAt: true;
    updatedAt: true;
};
declare type CommentGetSelectPayload<S extends boolean | CommentSelect> = S extends true ? Comment : S extends CommentSelect ? {
    [P in CleanupNever<MergeTruthyValues<{}, S>>]: P extends CommentScalars ? Comment[P] : P extends 'author' ? UserGetSelectPayload<ExtractUserSelectArgs<S[P]>> : P extends 'review' ? ReviewGetSelectPayload<ExtractReviewSelectArgs<S[P]>> | null : never;
} : never;
declare type CommentGetIncludePayload<S extends boolean | CommentInclude> = S extends true ? Comment : S extends CommentInclude ? {
    [P in CleanupNever<MergeTruthyValues<CommentDefault, S>>]: P extends CommentScalars ? Comment[P] : P extends 'author' ? UserGetIncludePayload<ExtractUserIncludeArgs<S[P]>> : P extends 'review' ? ReviewGetIncludePayload<ExtractReviewIncludeArgs<S[P]>> | null : never;
} : never;
export interface CommentDelegate {
    <T extends FindManyCommentArgs>(args?: Subset<T, FindManyCommentArgs>): T extends FindManyCommentArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyCommentSelectArgs ? Promise<Array<CommentGetSelectPayload<ExtractFindManyCommentSelectArgs<T>>>> : T extends FindManyCommentIncludeArgs ? Promise<Array<CommentGetIncludePayload<ExtractFindManyCommentIncludeArgs<T>>>> : Promise<Array<Comment>>;
    findOne<T extends FindOneCommentArgs>(args: Subset<T, FindOneCommentArgs>): T extends FindOneCommentArgsRequired ? 'Please either choose `select` or `include`' : T extends FindOneCommentSelectArgs ? Promise<CommentGetSelectPayload<ExtractFindOneCommentSelectArgs<T>> | null> : T extends FindOneCommentIncludeArgs ? Promise<CommentGetIncludePayload<ExtractFindOneCommentIncludeArgs<T>> | null> : CommentClient<Comment | null>;
    findMany<T extends FindManyCommentArgs>(args?: Subset<T, FindManyCommentArgs>): T extends FindManyCommentArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyCommentSelectArgs ? Promise<Array<CommentGetSelectPayload<ExtractFindManyCommentSelectArgs<T>>>> : T extends FindManyCommentIncludeArgs ? Promise<Array<CommentGetIncludePayload<ExtractFindManyCommentIncludeArgs<T>>>> : Promise<Array<Comment>>;
    create<T extends CommentCreateArgs>(args: Subset<T, CommentCreateArgs>): T extends CommentCreateArgsRequired ? 'Please either choose `select` or `include`' : T extends CommentSelectCreateArgs ? Promise<CommentGetSelectPayload<ExtractCommentSelectCreateArgs<T>>> : T extends CommentIncludeCreateArgs ? Promise<CommentGetIncludePayload<ExtractCommentIncludeCreateArgs<T>>> : CommentClient<Comment>;
    delete<T extends CommentDeleteArgs>(args: Subset<T, CommentDeleteArgs>): T extends CommentDeleteArgsRequired ? 'Please either choose `select` or `include`' : T extends CommentSelectDeleteArgs ? Promise<CommentGetSelectPayload<ExtractCommentSelectDeleteArgs<T>>> : T extends CommentIncludeDeleteArgs ? Promise<CommentGetIncludePayload<ExtractCommentIncludeDeleteArgs<T>>> : CommentClient<Comment>;
    update<T extends CommentUpdateArgs>(args: Subset<T, CommentUpdateArgs>): T extends CommentUpdateArgsRequired ? 'Please either choose `select` or `include`' : T extends CommentSelectUpdateArgs ? Promise<CommentGetSelectPayload<ExtractCommentSelectUpdateArgs<T>>> : T extends CommentIncludeUpdateArgs ? Promise<CommentGetIncludePayload<ExtractCommentIncludeUpdateArgs<T>>> : CommentClient<Comment>;
    deleteMany<T extends CommentDeleteManyArgs>(args: Subset<T, CommentDeleteManyArgs>): Promise<BatchPayload>;
    updateMany<T extends CommentUpdateManyArgs>(args: Subset<T, CommentUpdateManyArgs>): Promise<BatchPayload>;
    upsert<T extends CommentUpsertArgs>(args: Subset<T, CommentUpsertArgs>): T extends CommentUpsertArgsRequired ? 'Please either choose `select` or `include`' : T extends CommentSelectUpsertArgs ? Promise<CommentGetSelectPayload<ExtractCommentSelectUpsertArgs<T>>> : T extends CommentIncludeUpsertArgs ? Promise<CommentGetIncludePayload<ExtractCommentIncludeUpsertArgs<T>>> : CommentClient<Comment>;
    count(): Promise<number>;
}
export declare class CommentClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _path;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: DMMFClass, _fetcher: PhotonFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _path: string[], _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PhotonPromise';
    author<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): T extends FindOneUserArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectArgs ? Promise<UserGetSelectPayload<ExtractUserSelectArgs<T>> | null> : T extends UserIncludeArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeArgs<T>> | null> : UserClient<User | null>;
    review<T extends ReviewArgs = {}>(args?: Subset<T, ReviewArgs>): T extends FindOneReviewArgsRequired ? 'Please either choose `select` or `include`' : T extends ReviewSelectArgs ? Promise<ReviewGetSelectPayload<ExtractReviewSelectArgs<T>> | null> : T extends ReviewIncludeArgs ? Promise<ReviewGetIncludePayload<ExtractReviewIncludeArgs<T>> | null> : ReviewClient<Review | null>;
    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
/**
 * Comment findOne
 */
export declare type FindOneCommentArgs = {
    select?: CommentSelect | null;
    include?: CommentInclude | null;
    where: CommentWhereUniqueInput;
};
export declare type FindOneCommentArgsRequired = {
    select: CommentSelect;
    include: CommentInclude;
    where: CommentWhereUniqueInput;
};
export declare type FindOneCommentSelectArgs = {
    select: CommentSelect;
    where: CommentWhereUniqueInput;
};
export declare type FindOneCommentSelectArgsOptional = {
    select?: CommentSelect | null;
    where: CommentWhereUniqueInput;
};
export declare type FindOneCommentIncludeArgs = {
    include: CommentInclude;
    where: CommentWhereUniqueInput;
};
export declare type FindOneCommentIncludeArgsOptional = {
    include?: CommentInclude | null;
    where: CommentWhereUniqueInput;
};
export declare type ExtractFindOneCommentSelectArgs<S extends undefined | boolean | FindOneCommentSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneCommentSelectArgs ? S['select'] : true;
export declare type ExtractFindOneCommentIncludeArgs<S extends undefined | boolean | FindOneCommentIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneCommentIncludeArgs ? S['include'] : true;
/**
 * Comment findMany
 */
export declare type FindManyCommentArgs = {
    select?: CommentSelect | null;
    include?: CommentInclude | null;
    where?: CommentWhereInput | null;
    orderBy?: CommentOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyCommentArgsRequired = {
    select: CommentSelect;
    include: CommentInclude;
    where?: CommentWhereInput | null;
    orderBy?: CommentOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyCommentSelectArgs = {
    select: CommentSelect;
    where?: CommentWhereInput | null;
    orderBy?: CommentOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyCommentSelectArgsOptional = {
    select?: CommentSelect | null;
    where?: CommentWhereInput | null;
    orderBy?: CommentOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyCommentIncludeArgs = {
    include: CommentInclude;
    where?: CommentWhereInput | null;
    orderBy?: CommentOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyCommentIncludeArgsOptional = {
    include?: CommentInclude | null;
    where?: CommentWhereInput | null;
    orderBy?: CommentOrderByInput | null;
    skip?: number | null;
    after?: number | null;
    before?: number | null;
    first?: number | null;
    last?: number | null;
};
export declare type ExtractFindManyCommentSelectArgs<S extends undefined | boolean | FindManyCommentSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyCommentSelectArgs ? S['select'] : true;
export declare type ExtractFindManyCommentIncludeArgs<S extends undefined | boolean | FindManyCommentIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyCommentIncludeArgs ? S['include'] : true;
/**
 * Comment create
 */
export declare type CommentCreateArgs = {
    select?: CommentSelect | null;
    include?: CommentInclude | null;
    data: CommentCreateInput;
};
export declare type CommentCreateArgsRequired = {
    select: CommentSelect;
    include: CommentInclude;
    data: CommentCreateInput;
};
export declare type CommentSelectCreateArgs = {
    select: CommentSelect;
    data: CommentCreateInput;
};
export declare type CommentSelectCreateArgsOptional = {
    select?: CommentSelect | null;
    data: CommentCreateInput;
};
export declare type CommentIncludeCreateArgs = {
    include: CommentInclude;
    data: CommentCreateInput;
};
export declare type CommentIncludeCreateArgsOptional = {
    include?: CommentInclude | null;
    data: CommentCreateInput;
};
export declare type ExtractCommentSelectCreateArgs<S extends undefined | boolean | CommentSelectCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CommentSelectCreateArgs ? S['select'] : true;
export declare type ExtractCommentIncludeCreateArgs<S extends undefined | boolean | CommentIncludeCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CommentIncludeCreateArgs ? S['include'] : true;
/**
 * Comment update
 */
export declare type CommentUpdateArgs = {
    select?: CommentSelect | null;
    include?: CommentInclude | null;
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
};
export declare type CommentUpdateArgsRequired = {
    select: CommentSelect;
    include: CommentInclude;
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
};
export declare type CommentSelectUpdateArgs = {
    select: CommentSelect;
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
};
export declare type CommentSelectUpdateArgsOptional = {
    select?: CommentSelect | null;
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
};
export declare type CommentIncludeUpdateArgs = {
    include: CommentInclude;
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
};
export declare type CommentIncludeUpdateArgsOptional = {
    include?: CommentInclude | null;
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
};
export declare type ExtractCommentSelectUpdateArgs<S extends undefined | boolean | CommentSelectUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CommentSelectUpdateArgs ? S['select'] : true;
export declare type ExtractCommentIncludeUpdateArgs<S extends undefined | boolean | CommentIncludeUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CommentIncludeUpdateArgs ? S['include'] : true;
/**
 * Comment updateMany
 */
export declare type CommentUpdateManyArgs = {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput | null;
};
/**
 * Comment upsert
 */
export declare type CommentUpsertArgs = {
    select?: CommentSelect | null;
    include?: CommentInclude | null;
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
};
export declare type CommentUpsertArgsRequired = {
    select: CommentSelect;
    include: CommentInclude;
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
};
export declare type CommentSelectUpsertArgs = {
    select: CommentSelect;
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
};
export declare type CommentSelectUpsertArgsOptional = {
    select?: CommentSelect | null;
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
};
export declare type CommentIncludeUpsertArgs = {
    include: CommentInclude;
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
};
export declare type CommentIncludeUpsertArgsOptional = {
    include?: CommentInclude | null;
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
};
export declare type ExtractCommentSelectUpsertArgs<S extends undefined | boolean | CommentSelectUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CommentSelectUpsertArgs ? S['select'] : true;
export declare type ExtractCommentIncludeUpsertArgs<S extends undefined | boolean | CommentIncludeUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CommentIncludeUpsertArgs ? S['include'] : true;
/**
 * Comment delete
 */
export declare type CommentDeleteArgs = {
    select?: CommentSelect | null;
    include?: CommentInclude | null;
    where: CommentWhereUniqueInput;
};
export declare type CommentDeleteArgsRequired = {
    select: CommentSelect;
    include: CommentInclude;
    where: CommentWhereUniqueInput;
};
export declare type CommentSelectDeleteArgs = {
    select: CommentSelect;
    where: CommentWhereUniqueInput;
};
export declare type CommentSelectDeleteArgsOptional = {
    select?: CommentSelect | null;
    where: CommentWhereUniqueInput;
};
export declare type CommentIncludeDeleteArgs = {
    include: CommentInclude;
    where: CommentWhereUniqueInput;
};
export declare type CommentIncludeDeleteArgsOptional = {
    include?: CommentInclude | null;
    where: CommentWhereUniqueInput;
};
export declare type ExtractCommentSelectDeleteArgs<S extends undefined | boolean | CommentSelectDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CommentSelectDeleteArgs ? S['select'] : true;
export declare type ExtractCommentIncludeDeleteArgs<S extends undefined | boolean | CommentIncludeDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CommentIncludeDeleteArgs ? S['include'] : true;
/**
 * Comment deleteMany
 */
export declare type CommentDeleteManyArgs = {
    where?: CommentWhereInput | null;
};
/**
 * Comment without action
 */
export declare type CommentArgs = {
    select?: CommentSelect | null;
    include?: CommentInclude | null;
};
export declare type CommentArgsRequired = {
    select: CommentSelect;
    include: CommentInclude;
};
export declare type CommentSelectArgs = {
    select: CommentSelect;
};
export declare type CommentSelectArgsOptional = {
    select?: CommentSelect | null;
};
export declare type CommentIncludeArgs = {
    include: CommentInclude;
};
export declare type CommentIncludeArgsOptional = {
    include?: CommentInclude | null;
};
export declare type ExtractCommentSelectArgs<S extends undefined | boolean | CommentSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CommentSelectArgs ? S['select'] : true;
export declare type ExtractCommentIncludeArgs<S extends undefined | boolean | CommentIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CommentIncludeArgs ? S['include'] : true;
/**
 * Deep Input Types
 */
export declare type CommentWhereInput = {
    id?: number | IntFilter | null;
    createdAt?: Date | string | DateTimeFilter | null;
    updatedAt?: Date | string | DateTimeFilter | null;
    AND?: Enumerable<CommentWhereInput> | null;
    OR?: Enumerable<CommentWhereInput> | null;
    NOT?: Enumerable<CommentWhereInput> | null;
    author?: UserWhereInput | null;
    review?: ReviewWhereInput | null;
};
export declare type ReviewWhereInput = {
    id?: number | IntFilter | null;
    rating?: number | IntFilter | null;
    comments?: CommentFilter | null;
    AND?: Enumerable<ReviewWhereInput> | null;
    OR?: Enumerable<ReviewWhereInput> | null;
    NOT?: Enumerable<ReviewWhereInput> | null;
    restaurant?: RestaurantWhereInput | null;
    author?: UserWhereInput | null;
};
export declare type RestaurantWhereInput = {
    id?: number | IntFilter | null;
    reviews?: ReviewFilter | null;
    AND?: Enumerable<RestaurantWhereInput> | null;
    OR?: Enumerable<RestaurantWhereInput> | null;
    NOT?: Enumerable<RestaurantWhereInput> | null;
    creator?: UserWhereInput | null;
};
export declare type UserWhereInput = {
    id?: number | IntFilter | null;
    username?: string | StringFilter | null;
    role?: Role | RoleFilter | null;
    ownedRestaurants?: RestaurantFilter | null;
    authoredReviews?: ReviewFilter | null;
    authoredComments?: CommentFilter | null;
    createdAt?: Date | string | DateTimeFilter | null;
    AND?: Enumerable<UserWhereInput> | null;
    OR?: Enumerable<UserWhereInput> | null;
    NOT?: Enumerable<UserWhereInput> | null;
};
export declare type UserWhereUniqueInput = {
    id?: number | null;
};
export declare type RestaurantWhereUniqueInput = {
    id?: number | null;
};
export declare type ReviewWhereUniqueInput = {
    id?: number | null;
};
export declare type CommentWhereUniqueInput = {
    id?: number | null;
};
export declare type CommentCreateWithoutReviewInput = {
    id: number;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    author: UserCreateOneWithoutAuthorInput;
};
export declare type CommentCreateManyWithoutCommentsInput = {
    create?: Enumerable<CommentCreateWithoutReviewInput> | null;
    connect?: Enumerable<CommentWhereUniqueInput> | null;
};
export declare type ReviewCreateWithoutAuthorInput = {
    id: number;
    rating: number;
    restaurant: RestaurantCreateOneWithoutRestaurantInput;
    comments?: CommentCreateManyWithoutCommentsInput | null;
};
export declare type ReviewCreateManyWithoutAuthoredReviewsInput = {
    create?: Enumerable<ReviewCreateWithoutAuthorInput> | null;
    connect?: Enumerable<ReviewWhereUniqueInput> | null;
};
export declare type UserCreateWithoutOwnedRestaurantsInput = {
    id: number;
    username: string;
    role?: Role | null;
    createdAt?: Date | string | null;
    authoredReviews?: ReviewCreateManyWithoutAuthoredReviewsInput | null;
    authoredComments?: CommentCreateManyWithoutAuthoredCommentsInput | null;
};
export declare type UserCreateOneWithoutCreatorInput = {
    create?: UserCreateWithoutOwnedRestaurantsInput | null;
    connect?: UserWhereUniqueInput | null;
};
export declare type RestaurantCreateWithoutReviewsInput = {
    id: number;
    creator: UserCreateOneWithoutCreatorInput;
};
export declare type RestaurantCreateOneWithoutRestaurantInput = {
    create?: RestaurantCreateWithoutReviewsInput | null;
    connect?: RestaurantWhereUniqueInput | null;
};
export declare type ReviewCreateWithoutCommentsInput = {
    id: number;
    rating: number;
    restaurant: RestaurantCreateOneWithoutRestaurantInput;
    author: UserCreateOneWithoutAuthorInput;
};
export declare type ReviewCreateOneWithoutReviewInput = {
    create?: ReviewCreateWithoutCommentsInput | null;
    connect?: ReviewWhereUniqueInput | null;
};
export declare type CommentCreateWithoutAuthorInput = {
    id: number;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    review?: ReviewCreateOneWithoutReviewInput | null;
};
export declare type CommentCreateManyWithoutAuthoredCommentsInput = {
    create?: Enumerable<CommentCreateWithoutAuthorInput> | null;
    connect?: Enumerable<CommentWhereUniqueInput> | null;
};
export declare type UserCreateWithoutAuthoredReviewsInput = {
    id: number;
    username: string;
    role?: Role | null;
    createdAt?: Date | string | null;
    ownedRestaurants?: RestaurantCreateManyWithoutOwnedRestaurantsInput | null;
    authoredComments?: CommentCreateManyWithoutAuthoredCommentsInput | null;
};
export declare type UserCreateOneWithoutAuthorInput = {
    create?: UserCreateWithoutAuthoredReviewsInput | null;
    connect?: UserWhereUniqueInput | null;
};
export declare type ReviewCreateWithoutRestaurantInput = {
    id: number;
    rating: number;
    author: UserCreateOneWithoutAuthorInput;
    comments?: CommentCreateManyWithoutCommentsInput | null;
};
export declare type ReviewCreateManyWithoutReviewsInput = {
    create?: Enumerable<ReviewCreateWithoutRestaurantInput> | null;
    connect?: Enumerable<ReviewWhereUniqueInput> | null;
};
export declare type RestaurantCreateWithoutCreatorInput = {
    id: number;
    reviews?: ReviewCreateManyWithoutReviewsInput | null;
};
export declare type RestaurantCreateManyWithoutOwnedRestaurantsInput = {
    create?: Enumerable<RestaurantCreateWithoutCreatorInput> | null;
    connect?: Enumerable<RestaurantWhereUniqueInput> | null;
};
export declare type UserCreateInput = {
    id: number;
    username: string;
    role?: Role | null;
    createdAt?: Date | string | null;
    ownedRestaurants?: RestaurantCreateManyWithoutOwnedRestaurantsInput | null;
    authoredReviews?: ReviewCreateManyWithoutAuthoredReviewsInput | null;
    authoredComments?: CommentCreateManyWithoutAuthoredCommentsInput | null;
};
export declare type UserCreateWithoutAuthoredCommentsInput = {
    id: number;
    username: string;
    role?: Role | null;
    createdAt?: Date | string | null;
    ownedRestaurants?: RestaurantCreateManyWithoutOwnedRestaurantsInput | null;
    authoredReviews?: ReviewCreateManyWithoutAuthoredReviewsInput | null;
};
export declare type UserUpdateWithoutAuthoredCommentsDataInput = {
    id?: number | null;
    username?: string | null;
    role?: Role | null;
    createdAt?: Date | string | null;
    ownedRestaurants?: RestaurantUpdateManyWithoutCreatorInput | null;
    authoredReviews?: ReviewUpdateManyWithoutAuthorInput | null;
};
export declare type UserUpsertWithoutAuthoredCommentsInput = {
    update: UserUpdateWithoutAuthoredCommentsDataInput;
    create: UserCreateWithoutAuthoredCommentsInput;
};
export declare type UserUpdateOneRequiredWithoutAuthoredCommentsInput = {
    create?: UserCreateWithoutAuthoredCommentsInput | null;
    connect?: UserWhereUniqueInput | null;
    update?: UserUpdateWithoutAuthoredCommentsDataInput | null;
    upsert?: UserUpsertWithoutAuthoredCommentsInput | null;
};
export declare type CommentUpdateWithoutReviewDataInput = {
    id?: number | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    author?: UserUpdateOneRequiredWithoutAuthoredCommentsInput | null;
};
export declare type CommentUpdateWithWhereUniqueWithoutReviewInput = {
    where: CommentWhereUniqueInput;
    data: CommentUpdateWithoutReviewDataInput;
};
export declare type CommentScalarWhereInput = {
    id?: number | IntFilter | null;
    createdAt?: Date | string | DateTimeFilter | null;
    updatedAt?: Date | string | DateTimeFilter | null;
    AND?: Enumerable<CommentScalarWhereInput> | null;
    OR?: Enumerable<CommentScalarWhereInput> | null;
    NOT?: Enumerable<CommentScalarWhereInput> | null;
};
export declare type CommentUpdateManyDataInput = {
    id?: number | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
};
export declare type CommentUpdateManyWithWhereNestedInput = {
    where: CommentScalarWhereInput;
    data: CommentUpdateManyDataInput;
};
export declare type CommentUpsertWithWhereUniqueWithoutReviewInput = {
    where: CommentWhereUniqueInput;
    update: CommentUpdateWithoutReviewDataInput;
    create: CommentCreateWithoutReviewInput;
};
export declare type CommentUpdateManyWithoutReviewInput = {
    create?: Enumerable<CommentCreateWithoutReviewInput> | null;
    connect?: Enumerable<CommentWhereUniqueInput> | null;
    set?: Enumerable<CommentWhereUniqueInput> | null;
    disconnect?: Enumerable<CommentWhereUniqueInput> | null;
    delete?: Enumerable<CommentWhereUniqueInput> | null;
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutReviewInput> | null;
    updateMany?: Enumerable<CommentUpdateManyWithWhereNestedInput> | null;
    deleteMany?: Enumerable<CommentScalarWhereInput> | null;
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutReviewInput> | null;
};
export declare type ReviewUpdateWithoutAuthorDataInput = {
    id?: number | null;
    rating?: number | null;
    restaurant?: RestaurantUpdateOneRequiredWithoutReviewsInput | null;
    comments?: CommentUpdateManyWithoutReviewInput | null;
};
export declare type ReviewUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ReviewWhereUniqueInput;
    data: ReviewUpdateWithoutAuthorDataInput;
};
export declare type ReviewScalarWhereInput = {
    id?: number | IntFilter | null;
    rating?: number | IntFilter | null;
    comments?: CommentFilter | null;
    AND?: Enumerable<ReviewScalarWhereInput> | null;
    OR?: Enumerable<ReviewScalarWhereInput> | null;
    NOT?: Enumerable<ReviewScalarWhereInput> | null;
};
export declare type ReviewUpdateManyDataInput = {
    id?: number | null;
    rating?: number | null;
};
export declare type ReviewUpdateManyWithWhereNestedInput = {
    where: ReviewScalarWhereInput;
    data: ReviewUpdateManyDataInput;
};
export declare type ReviewUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ReviewWhereUniqueInput;
    update: ReviewUpdateWithoutAuthorDataInput;
    create: ReviewCreateWithoutAuthorInput;
};
export declare type ReviewUpdateManyWithoutAuthorInput = {
    create?: Enumerable<ReviewCreateWithoutAuthorInput> | null;
    connect?: Enumerable<ReviewWhereUniqueInput> | null;
    set?: Enumerable<ReviewWhereUniqueInput> | null;
    disconnect?: Enumerable<ReviewWhereUniqueInput> | null;
    delete?: Enumerable<ReviewWhereUniqueInput> | null;
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutAuthorInput> | null;
    updateMany?: Enumerable<ReviewUpdateManyWithWhereNestedInput> | null;
    deleteMany?: Enumerable<ReviewScalarWhereInput> | null;
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutAuthorInput> | null;
};
export declare type UserUpdateWithoutOwnedRestaurantsDataInput = {
    id?: number | null;
    username?: string | null;
    role?: Role | null;
    createdAt?: Date | string | null;
    authoredReviews?: ReviewUpdateManyWithoutAuthorInput | null;
    authoredComments?: CommentUpdateManyWithoutAuthorInput | null;
};
export declare type UserUpsertWithoutOwnedRestaurantsInput = {
    update: UserUpdateWithoutOwnedRestaurantsDataInput;
    create: UserCreateWithoutOwnedRestaurantsInput;
};
export declare type UserUpdateOneRequiredWithoutOwnedRestaurantsInput = {
    create?: UserCreateWithoutOwnedRestaurantsInput | null;
    connect?: UserWhereUniqueInput | null;
    update?: UserUpdateWithoutOwnedRestaurantsDataInput | null;
    upsert?: UserUpsertWithoutOwnedRestaurantsInput | null;
};
export declare type RestaurantUpdateWithoutReviewsDataInput = {
    id?: number | null;
    creator?: UserUpdateOneRequiredWithoutOwnedRestaurantsInput | null;
};
export declare type RestaurantUpsertWithoutReviewsInput = {
    update: RestaurantUpdateWithoutReviewsDataInput;
    create: RestaurantCreateWithoutReviewsInput;
};
export declare type RestaurantUpdateOneRequiredWithoutReviewsInput = {
    create?: RestaurantCreateWithoutReviewsInput | null;
    connect?: RestaurantWhereUniqueInput | null;
    update?: RestaurantUpdateWithoutReviewsDataInput | null;
    upsert?: RestaurantUpsertWithoutReviewsInput | null;
};
export declare type ReviewUpdateWithoutCommentsDataInput = {
    id?: number | null;
    rating?: number | null;
    restaurant?: RestaurantUpdateOneRequiredWithoutReviewsInput | null;
    author?: UserUpdateOneRequiredWithoutAuthoredReviewsInput | null;
};
export declare type ReviewUpsertWithoutCommentsInput = {
    update: ReviewUpdateWithoutCommentsDataInput;
    create: ReviewCreateWithoutCommentsInput;
};
export declare type ReviewUpdateOneWithoutCommentsInput = {
    create?: ReviewCreateWithoutCommentsInput | null;
    connect?: ReviewWhereUniqueInput | null;
    disconnect?: boolean | null;
    delete?: boolean | null;
    update?: ReviewUpdateWithoutCommentsDataInput | null;
    upsert?: ReviewUpsertWithoutCommentsInput | null;
};
export declare type CommentUpdateWithoutAuthorDataInput = {
    id?: number | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    review?: ReviewUpdateOneWithoutCommentsInput | null;
};
export declare type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput;
    data: CommentUpdateWithoutAuthorDataInput;
};
export declare type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput;
    update: CommentUpdateWithoutAuthorDataInput;
    create: CommentCreateWithoutAuthorInput;
};
export declare type CommentUpdateManyWithoutAuthorInput = {
    create?: Enumerable<CommentCreateWithoutAuthorInput> | null;
    connect?: Enumerable<CommentWhereUniqueInput> | null;
    set?: Enumerable<CommentWhereUniqueInput> | null;
    disconnect?: Enumerable<CommentWhereUniqueInput> | null;
    delete?: Enumerable<CommentWhereUniqueInput> | null;
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutAuthorInput> | null;
    updateMany?: Enumerable<CommentUpdateManyWithWhereNestedInput> | null;
    deleteMany?: Enumerable<CommentScalarWhereInput> | null;
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutAuthorInput> | null;
};
export declare type UserUpdateWithoutAuthoredReviewsDataInput = {
    id?: number | null;
    username?: string | null;
    role?: Role | null;
    createdAt?: Date | string | null;
    ownedRestaurants?: RestaurantUpdateManyWithoutCreatorInput | null;
    authoredComments?: CommentUpdateManyWithoutAuthorInput | null;
};
export declare type UserUpsertWithoutAuthoredReviewsInput = {
    update: UserUpdateWithoutAuthoredReviewsDataInput;
    create: UserCreateWithoutAuthoredReviewsInput;
};
export declare type UserUpdateOneRequiredWithoutAuthoredReviewsInput = {
    create?: UserCreateWithoutAuthoredReviewsInput | null;
    connect?: UserWhereUniqueInput | null;
    update?: UserUpdateWithoutAuthoredReviewsDataInput | null;
    upsert?: UserUpsertWithoutAuthoredReviewsInput | null;
};
export declare type ReviewUpdateWithoutRestaurantDataInput = {
    id?: number | null;
    rating?: number | null;
    author?: UserUpdateOneRequiredWithoutAuthoredReviewsInput | null;
    comments?: CommentUpdateManyWithoutReviewInput | null;
};
export declare type ReviewUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: ReviewWhereUniqueInput;
    data: ReviewUpdateWithoutRestaurantDataInput;
};
export declare type ReviewUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: ReviewWhereUniqueInput;
    update: ReviewUpdateWithoutRestaurantDataInput;
    create: ReviewCreateWithoutRestaurantInput;
};
export declare type ReviewUpdateManyWithoutRestaurantInput = {
    create?: Enumerable<ReviewCreateWithoutRestaurantInput> | null;
    connect?: Enumerable<ReviewWhereUniqueInput> | null;
    set?: Enumerable<ReviewWhereUniqueInput> | null;
    disconnect?: Enumerable<ReviewWhereUniqueInput> | null;
    delete?: Enumerable<ReviewWhereUniqueInput> | null;
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutRestaurantInput> | null;
    updateMany?: Enumerable<ReviewUpdateManyWithWhereNestedInput> | null;
    deleteMany?: Enumerable<ReviewScalarWhereInput> | null;
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutRestaurantInput> | null;
};
export declare type RestaurantUpdateWithoutCreatorDataInput = {
    id?: number | null;
    reviews?: ReviewUpdateManyWithoutRestaurantInput | null;
};
export declare type RestaurantUpdateWithWhereUniqueWithoutCreatorInput = {
    where: RestaurantWhereUniqueInput;
    data: RestaurantUpdateWithoutCreatorDataInput;
};
export declare type RestaurantScalarWhereInput = {
    id?: number | IntFilter | null;
    reviews?: ReviewFilter | null;
    AND?: Enumerable<RestaurantScalarWhereInput> | null;
    OR?: Enumerable<RestaurantScalarWhereInput> | null;
    NOT?: Enumerable<RestaurantScalarWhereInput> | null;
};
export declare type RestaurantUpdateManyDataInput = {
    id?: number | null;
};
export declare type RestaurantUpdateManyWithWhereNestedInput = {
    where: RestaurantScalarWhereInput;
    data: RestaurantUpdateManyDataInput;
};
export declare type RestaurantUpsertWithWhereUniqueWithoutCreatorInput = {
    where: RestaurantWhereUniqueInput;
    update: RestaurantUpdateWithoutCreatorDataInput;
    create: RestaurantCreateWithoutCreatorInput;
};
export declare type RestaurantUpdateManyWithoutCreatorInput = {
    create?: Enumerable<RestaurantCreateWithoutCreatorInput> | null;
    connect?: Enumerable<RestaurantWhereUniqueInput> | null;
    set?: Enumerable<RestaurantWhereUniqueInput> | null;
    disconnect?: Enumerable<RestaurantWhereUniqueInput> | null;
    delete?: Enumerable<RestaurantWhereUniqueInput> | null;
    update?: Enumerable<RestaurantUpdateWithWhereUniqueWithoutCreatorInput> | null;
    updateMany?: Enumerable<RestaurantUpdateManyWithWhereNestedInput> | null;
    deleteMany?: Enumerable<RestaurantScalarWhereInput> | null;
    upsert?: Enumerable<RestaurantUpsertWithWhereUniqueWithoutCreatorInput> | null;
};
export declare type UserUpdateInput = {
    id?: number | null;
    username?: string | null;
    role?: Role | null;
    createdAt?: Date | string | null;
    ownedRestaurants?: RestaurantUpdateManyWithoutCreatorInput | null;
    authoredReviews?: ReviewUpdateManyWithoutAuthorInput | null;
    authoredComments?: CommentUpdateManyWithoutAuthorInput | null;
};
export declare type UserUpdateManyMutationInput = {
    id?: number | null;
    username?: string | null;
    role?: Role | null;
    createdAt?: Date | string | null;
};
export declare type RestaurantCreateInput = {
    id: number;
    creator: UserCreateOneWithoutCreatorInput;
    reviews?: ReviewCreateManyWithoutReviewsInput | null;
};
export declare type RestaurantUpdateInput = {
    id?: number | null;
    creator?: UserUpdateOneRequiredWithoutOwnedRestaurantsInput | null;
    reviews?: ReviewUpdateManyWithoutRestaurantInput | null;
};
export declare type RestaurantUpdateManyMutationInput = {
    id?: number | null;
};
export declare type ReviewCreateInput = {
    id: number;
    rating: number;
    restaurant: RestaurantCreateOneWithoutRestaurantInput;
    author: UserCreateOneWithoutAuthorInput;
    comments?: CommentCreateManyWithoutCommentsInput | null;
};
export declare type ReviewUpdateInput = {
    id?: number | null;
    rating?: number | null;
    restaurant?: RestaurantUpdateOneRequiredWithoutReviewsInput | null;
    author?: UserUpdateOneRequiredWithoutAuthoredReviewsInput | null;
    comments?: CommentUpdateManyWithoutReviewInput | null;
};
export declare type ReviewUpdateManyMutationInput = {
    id?: number | null;
    rating?: number | null;
};
export declare type CommentCreateInput = {
    id: number;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    author: UserCreateOneWithoutAuthorInput;
    review?: ReviewCreateOneWithoutReviewInput | null;
};
export declare type CommentUpdateInput = {
    id?: number | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    author?: UserUpdateOneRequiredWithoutAuthoredCommentsInput | null;
    review?: ReviewUpdateOneWithoutCommentsInput | null;
};
export declare type CommentUpdateManyMutationInput = {
    id?: number | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
};
export declare type IntFilter = {
    equals?: number | null;
    not?: number | IntFilter | null;
    in?: Enumerable<number> | null;
    notIn?: Enumerable<number> | null;
    lt?: number | null;
    lte?: number | null;
    gt?: number | null;
    gte?: number | null;
};
export declare type DateTimeFilter = {
    equals?: Date | string | null;
    not?: Date | string | DateTimeFilter | null;
    in?: Enumerable<Date | string> | null;
    notIn?: Enumerable<Date | string> | null;
    lt?: Date | string | null;
    lte?: Date | string | null;
    gt?: Date | string | null;
    gte?: Date | string | null;
};
export declare type CommentFilter = {
    every?: CommentWhereInput | null;
    some?: CommentWhereInput | null;
    none?: CommentWhereInput | null;
};
export declare type ReviewFilter = {
    every?: ReviewWhereInput | null;
    some?: ReviewWhereInput | null;
    none?: ReviewWhereInput | null;
};
export declare type StringFilter = {
    equals?: string | null;
    not?: string | StringFilter | null;
    in?: Enumerable<string> | null;
    notIn?: Enumerable<string> | null;
    lt?: string | null;
    lte?: string | null;
    gt?: string | null;
    gte?: string | null;
    contains?: string | null;
    startsWith?: string | null;
    endsWith?: string | null;
};
export declare type RoleFilter = {};
export declare type RestaurantFilter = {
    every?: RestaurantWhereInput | null;
    some?: RestaurantWhereInput | null;
    none?: RestaurantWhereInput | null;
};
export declare type UserOrderByInput = {
    id?: OrderByArg | null;
    username?: OrderByArg | null;
    role?: OrderByArg | null;
    createdAt?: OrderByArg | null;
};
export declare type RestaurantOrderByInput = {
    id?: OrderByArg | null;
};
export declare type ReviewOrderByInput = {
    id?: OrderByArg | null;
    rating?: OrderByArg | null;
};
export declare type CommentOrderByInput = {
    id?: OrderByArg | null;
    createdAt?: OrderByArg | null;
    updatedAt?: OrderByArg | null;
};
/**
 * Batch Payload for updateMany & deleteMany
 */
export declare type BatchPayload = {
    count: number;
};
/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
